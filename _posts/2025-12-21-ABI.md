---
layout: post
title: "The Invisible Handshake: Understanding The ABI When Mixing Programming Languages"
date: 2025-12-21
categories: [programming]
---

In modern software development, it is increasingly common to encounter projects built using multiple programming languages. You might have a high-level web server written in Go or Python that, for performance-critical tasks, calls down into a blazing-fast library written in C or Rust.

The magic trick enabling this coexistence is the **Linker**. The linker takes independent "object files"—raw machine code generated by different compilers—and stitches them into a single executable.

But here is the catch: just because two pieces of code are combined into one binary doesn't mean they know how to talk to each other.

If a Python function tries to call a C function, they need to agree on the ground rules of communication at the hardware level. If they don’t, chaos ensues. Those ground rules are defined by the **Application Binary Interface**, or **ABI**.

### API vs. ABI: What’s the Difference?

Most developers are familiar with an **API (Application Programming Interface)**. An API is a contract at the _source code_ level. It tells a human programmer: "If you want to use this function, you must provide an integer and a string, and I will return a boolean."

An **ABI** is a contract at the _machine code_ (binary) level. It tells the CPU and the generated code things like:

- "Where do I put the first argument? Register 0 or on the stack?"
    
- "Who is responsible for cleaning up the memory after the function runs? The caller or the callee?"
    
- "If a function returns a value, which CPU register will it be sitting in?"
    
- "How is a struct laid out in memory? Is there padding between fields?"
    

If two compiled languages don't agree on the ABI, the program might compile and link successfully, but it will crash or produce garbage data at runtime.

### The Disaster of Disagreeing ABIs

To illustrate why the ABI is so crucial, let's look at the example. These scenarios show what happens when two theoretical languages—let's call them Language A and Language B—try to interact without an agreed-upon ABI.

Both languages are compiled into machine code for the same CPU architecture, but their compilers made different assumptions about how data should be handled.

#### Scenario 1: The "Wrong Register" Problem

Imagine Language A wants to call a function defined in Language B that accepts two parameters.

- **The Setup:** The compiler for **Language A** follows a convention where the first two arguments are placed in CPU **Register 0** and **Register 1**.
    
- **The Mismatch:** The compiler for **Language B**, however, was built differently. It expects incoming arguments to be waiting in **Register 1** and **Register 2**.
    

When the program runs, Language A dutifully places its data in R0 and R1 and jumps to the function in Language B. Language B's code wakes up, ignores R0 entirely, grabs the second argument from R1, and then grabs whatever random garbage data happens to be sitting in R2.

The result is undefined behavior. The function receives completely incorrect data.

It gets worse. What about the return value?

- **The Setup:** The function in **Language B** finishes its calculation and places the result in **Register 1** before returning.
    
- **The Mismatch:** **Language A** expects function results to always be returned in **Register 0**.
    

Language A regains control, looks at Register 0, sees nothing new, and proceeds as if the function returned garbage. The actual result in Register 1 is ignored.

#### Scenario 2: The "Data Representation" Disaster

This example presented an even more catastrophic example involving how data is actually represented in memory—specifically, "pass-by-value" versus "pass-by-reference."

Let's look at two new theoretical languages: **Language X** and **Language Y**. Both agree on _which_ registers to use (say, Register 0 and Register 1), but they disagree on _what_ those registers contain.

- **Language X (The Caller):** This language uses **pass-by-reference**. When it passes variables to a function, it doesn't pass the actual values (e.g., the number 42). Instead, it puts the _memory addresses_ where those values are stored into the registers.
    
- **Language Y (The Callee):** This language uses **pass-by-value**. It expects the registers to contain the actual raw data it needs to operate on.
    

**The Result:** Language X puts two memory addresses into the registers and calls the function. The code in Language Y immediately takes the contents of those registers—which are huge memory address numbers—and tries to perform math on them, perhaps adding them together.

Instead of adding two small integers, the program adds two memory locations. The result is wildly incorrect, and if the program tries to access the resulting memory address, it will almost certainly crash with a segmentation fault.

### The Fix: Enforcing the ABI Contract

So, how do projects like the Linux kernel, Firefox, or complex embedded systems mix C, C++, Rust, and Assembly without constant crashing?

They explicitly tell their compilers which ABI contract to follow for the boundaries between languages.

Because C has been around for so long and is the foundation of nearly all operating systems, the **C ABI** has become the universal "lingua franca" of programming. If you want Python to talk to Rust, they usually don't talk directly; they both agree to speak the C ABI at the boundary where they meet.

Modern languages provide keywords to enforce this. As mentioned in the video:

- In **Rust**, you use `extern "C"` before a function definition to tell the Rust compiler: "Don't use your usual fancy Rust calling conventions here. Use the standard C convention so other languages can call this."
    
- In **C++**, you also use an `extern "C"` block to prevent C++ from "mangling" function names, ensuring the linker can find them and that the C calling convention is used.
    
- In **Fortran**, you use the `bind(C)` attribute.
    

By explicitly declaring these boundaries, developers ensure that both sides of the handshake agree on which registers to use, how memory is laid out, and how data is passed.

### Conclusion

When working in high-level languages, we rarely have to think about CPU registers or memory addresses. The compiler handles those details for us. But when projects span multiple languages, those details suddenly matter immensely.

The ABI is the unsung hero of system interoperability. It is the rigid set of low-level rules that ensures that when one binary component reaches out to shake hands with another, it doesn't accidentally punch it in the face.
